# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 操作文件的函数/方法
# --open函数负责打开文件，并且返回文件对象
# --read/write/close三个方法需要通过文件对象来调用

# 读取文件
# open函数的第一个参数是要打开的文件名（文件名区分大小写）
# -如果文件存在，则返回文件操作对象
# -如果文件不存在，报错
# read方法
# -可以一次性调入病返回文件的所有内容
# -方法执行后，文件指针将指向文件末尾
# colse方法负责关闭文件
# -如果忘记关闭文件，造成资源消耗，影响后续操作，因此写完open建议直接写colse方法，在补充中间的读写操作

# 打开文件
file = open("readme")
# 读取文件内容
text = file.read()
print(text)
print('-' * 20)
# 读取完文件后，文件指针将指向末尾，因此下方输出为空
text2 = file.read()
print(text2)
# 关闭文件
a = file.close()
# open函数默认以只读方式打开文件，并返回文件对象
# 语法：
# open('文件名','访问方法')
# 其他访问方法：
# r : 只读方式，文件指针初始在开头，默认模式 ；如果文件不存在，则抛出异常
# w : 只写方式，文件已存在将会被覆盖 ；如果文件不存在，则会新建
# a : 追加方式，如果文件已存在，指针将会放在末尾处，进行添加；如果文件不存在，则会新建
# r+ : 读写方式，文件指针初始在开头
# w+ : 读写方式，文件存在会被覆盖
# a+ : 读写方式，文件存在，指针将会在末尾，不存在会新建
# *** 频繁的移动指针，将会造成资源消耗，因此常用的是前三种方式

# 从头写
file = open('readme', 'w')
file.write('hello 0'+'\n')
file.close()
# 追加写
file = open('readme', 'a')
file.write('hello 1'+'\n')
file.close()
# 只读
file = open('readme', 'r')
txt = file.read()
print(txt)
file.close()
# 按行读取文件，使用readline(),每次仅读取一行
# readline()有一个参数，参数size表示从文件读取的字节数。
# 读取时，会将换行符'\n'也读取出来
# 需要遍历每一行文件时，使用该方法遍历
file = open('readme')
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline()
print(txt)
print('*' * 20)
txt = file.readline(1000)
print(txt)
file.close()

# readlines() #读取文本所有内容，并且以数列的格式返回结果，一般配合for in使用
# readline和readlines的区别：
# 1、readline()按行读取，readlines()一次性读取整个文件，返回的是所有行组成的列表。
# 2、.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理
# 3、仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。

file = open('readme')
txt = file.readlines()
print(type(txt))
print(txt[0:6])
file.close()
print('-' * 20)

# 导出内容问题：
# 导出内容中带有换行符如：['hello 0\n', 'hello 1\n', 'hello 3\n', 'hello 4\n', 'hello 5\n', 'hello 6\n']
# 解决办法

# 写入方法：
# 1.打开文件时使用参数w：覆盖之前内容写入
# 2.打开文件时使用参数a:从文件末尾处写入：append

f = open('write', 'w')
f.write('123' + '\n'
        '234' + '\n')
f.close()

f = open('write', 'a')
f.write('345' + '\n'
        '456' + '\n')
f.close()

f = open('write')
txt = f.readlines()
print(txt)
f.close()
# 用with内置函数，它可以将文件自动关闭，格式如下：
# with open（“”，“”）as f:

with open('readme') as f:
    txt = f.readlines()
    print(txt)

with open('write', 'a') as f:
    f.write('使用with方法插入')

# excel的读取写：Pandas方法
# 安装方法：
# 1、pip install pandas
# 2、pip install xlrd
# 参考：https://www.cnblogs.com/liulinghua90/p/9935642.html
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484097&idx=1&sn=ad8fabbd84bf67655996026fc0ac5688&chksm=fe1863e4c96feaf200e9398bb7c824e99d3fc01ec965666497ce584466dc93f83dd5d127a46d&scene=21#wechat_redirect
# https://mp.weixin.qq.com/s?__biz=MzU5Mjg2OTQ1MA==&mid=2247484131&idx=1&sn=137286d36c707e10bbc761681a666654&chksm=fe1863c6c96fead0e7b2ab9af2db28f0c26df2b878eb66930e69f23bdc611b7f34cadb0b7d50&scene=21#wechat_redirect


# 读取excel
# 方法1：默认读取第一个表单；类似打开文件方法，将excel读取出来，得到的结果是一个二维矩阵
import pandas as pd

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
excel = pd.read_excel(file_path)
print(excel)
print('*' * 100)

# 方法二：通过指定表单名的方式来读取，读取代码中增加sheet_name参数
excel = pd.read_excel(file_path, sheet_name='test1')
print(f"可以通过指定sheet方法输出内容：\n{excel}")
print('*' * 100)

# 方法三：通过表单索引来指定要访问的表单，0表示第一个表单，即sheet_name值
# 也可以采用表单名和索引的双重方式来定位表单
# 也可以同时定位多个表单，方式都罗列如下所示
try:
    df = pd.read_excel(file_path, sheet_name=['test1', 'test2'])
    print(f"可以通过制定sheet_name数组索引或者值方式输出：\n{excel}")
except Exception as result:
    print(f'出现问题啦：{format(result)}')
finally:
    print('*' * 100)


import pandas as pd
import numpy as np

file_path = '/Users/sunwenxiao/Desktop/test.xlsx'
# 默认读取前5行，df.head()，head后面也可以加参数
df = pd.read_excel(file_path)
print(df.head())
print('*' * 50)

# 默认读取后5行，df.tail(),括号中可以加参数
df = pd.read_excel(file_path)
# 输出后10行
print(df.tail(10))
print('*' * 50)

# 索引操作
#   不包含第一行
#   df.iloc[行索引,列索引]（索引从0开始，输出内容含首不含尾）
#   行索引：表示需要选取那几行
#   列索引：表示需要选取那几列

# 选择某几行
df = pd.read_excel(file_path)
print(df.iloc[3:8, :])
print('*' * 50)

# 选择某几列:
# 如果我们要跨列选取，得先把位置参数构造成列表形式，这里就是[0,4]，
# 如果是连续选取，则无需构造成列表，直接输入0:5
# 1.连续列，使用x:y
df = pd.read_excel(file_path)
print(df.iloc[:, 0: 1])
print('*' * 50)
# 2.跨列选择，使用[x,y]
df = pd.read_excel(file_path)
print(df.iloc[:, [0, 2]])
print('*' * 50)

# 行列交叉选择：将行列选择合并到一起，选择对应的索引
df = pd.read_excel(file_path)
# 输出部分姓名和年年
print(df.iloc[3:8, 0:2])
print('*' * 50)

# 基于名称（标签）的索引
# 筛选出第一列满足的值：df['姓名'] == '小米'，返回结果是true/false
# 使用df.loc根据筛选出来的值，展示true的内容
df = pd.read_excel(file_path)
print(df['姓名'] == '小米')
print(df.loc[df['姓名'] == '小米', :])
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:readandwrite.py
@Time:NAME.py@Time:2020/7/23 19:21
"""
import os
file_path = os.getcwd()
list_file = os.listdir()    # 读取当前文件夹所有文件
print(list_file)
for file_name in list_file:
    # file_name2 = str.split(file_name, '.')[0]
    with open(file_name, 'r', encoding='utf-8') as f:
        # 读取每个文件，返回为列表
        str = f.read()
        # print(f.read())
    with open('write0723', 'a', encoding='utf-8') as file:
        file.write(str)





hello 1
hello 2
hello 3
hello 4
hello 5
hello 6
hello 7
123
234
345
456
# 模块的概念：
# --每一个以扩展名  .py 为结尾的Python文件都是一个模块
# --模块名称同样也是标识符，需要符合命名规则
# --在模块中定义的  全局变量、 函数、 类  都是提供给外部直接使用的工具

import a_被导入模块01


# 调用导入的全局变量
print(a_被导入模块01.title)
# 调用导入的函数
print(a_被导入模块01.hanshu())
# 调用导入的类
h = a_被导入模块01.lei()
print(h)
# 当导入模块的名称过长是，可以使用给模块建一个别名，避免代码中模块名称够长
# 模块导入的别名也应该符合大驼峰命名法
import a_被导入模块01 as Im


hanshu = Im.hanshu()
print(f'{hanshu}')
print(Im.title)
lei = Im.lei()
print(lei)# from ..import 导入部分
# 如果希望从一个模块中，导入部分工具，就可以使用from ..import 导入
# 局部导入的好处；
# --使用不需要通过模块名.
# --可以直接使用模块提供的工具--全部变量、函数、类
# 局部导入注意问题：
# --如果两个模块，存在同名函数，那后导入的函数会覆盖先导入的函数
# --可以使用 from 模块名 import * 导入全部工具，但是不推荐使用，因为出现重名时不好排查


from a_被导入模块01 import hanshu
from a_被导入模块02 import lei02
# 导入同名的全局变量，输出的内容为后导入模块中的
from a_被导入模块01 import title
from a_被导入模块02 import title
# 局部导入后，可以直接使用其全部变量、函数、类
print(hanshu())
lei = lei02()
print(lei)
print(title)
# 当局部导入的模块存在同名的情况时，可以对局部导入的内容起别名

from a_被导入模块01 import hanshu as hanshu01
from a_被导入模块02 import hanshu as hanshu02

# 使用导入内容时，使用别名即可避免同名问题
hs1 = hanshu01()
print(hs1)
hs2 = hanshu02()
print(hs2)
# 在导入文件时，文件中所有没有任何缩进的代码 都会被直接执行一遍
# 原因：直接执行的代码，不属于给外部提供的工具，对外界提供的内容只有全局变量、函数、类

# 由于{a_被导入模块01}模块有未缩进的代码块，因此导入后，未缩进得代码块就会被执行

# 由于该模块使用了__name__判断，因此没有代码被直接执行

import a_被导入的模块03

# 因为在被导入得模块中，因此下方语句输出内容为:a_被导入的模块03
print(a_被导入的模块03.__name__)
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:a06_time模块.py
@Time:NAME.py@Time:2020/7/8 下午11:44
"""
# #python time模块主要包含各种提供日期、时间功能的相关函数。
# time模块既提供了把日期、时间格式化为字符串的功能，也提供了从字符串恢复日期、时间的功能。
# 全局变量
title = '全局变量-模块1'
print('123')


# 函数
def hanshu():
    return '函数-模块1'


print(hanshu())


# 类
class lei(object):

    def __str__(self):
        return '类-模块1'


lei = lei()
print(lei)
# 全局变量
title = '全局变量-模块2'


# 函数
def hanshu():
    return '函数-模块2'


# 类
class lei02(object):

    def __str__(self):
        return '类-模块2'# 模块使用__name__方法，将不需要被其他模块导入得内容，放置在main方法中
# 在函数本身文件中，__name__恒等于__main__
# 在被导入其他文件中时，__name__等于被导入文件名
# 因此可以使用__name__，将不希望被其他模块使用得内容，放在main函数中


class Dog(object):
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f'狗狗的名字是：{self.name}'


# 将不需要外部模块使用的代码，写到main函数中
def main():
    wangcai = Dog('旺财')
    print(wangcai)
    # 因为在文件本体汇总，因此下句输出内容为__main__
    print(__name__)


# 在文件中，使用如下判断,如果在本体中，则会执行main()，如果不是，则不执行
if __name__ == '__main__':
    main()





# 写入希望被外部使用的模块名
from . import receive_message
from . import send_message



包的概念
1、包 是一个包含多模块的特殊目录
2、目录下面有一个特殊的文件 __init__.py
3、包名的命名方式 和变量名一致， 小写字母+_

包的好处
使用import 包名 可以一次性导入包中的所有模块

__init__.py
1、要在外界使用 包 中的模块，需要在 __init__.py中指定对外界提供的模块
2、只有写在__init__.py中的模块，才能在其他模块中调用
3、写法： from . import xxxdef receive_m(text):
    print(f'收到的内容是：{text}')
class Send_Message(object):
    def __str__(self):
        return '123123'
import b_package

# 导入包后，需要使用包名.模块名.方法/类等
b_package.receive_message.receive_m('hello')
a = b_package.send_message.Send_Message()

print(f'{a}')
print(b_package.send_message.Send_Message)
# !usr/bin/env python
# -*- coding:utf-8 _*-
"""
@Author:孙泽
@Github:https://github.com/huochelueguo
@File:文件夹包含文件夹读取.py
@Time:NAME.py@Time:2020/7/24 上午8:46
"""
# 25_模块文件中，存在文件夹中还有文件夹的情况，通过嵌套的方法读取
import os


def get_file(path):
    for file in os.listdir(path):
        i = os.path.join(path, file)
        if os.path.isdir(i):    # 判断某个文件是否为文件夹时，最好使用os.path.join将路径和文件夹拼起来后再去判断
            print(f'路径中有文件夹包含文件夹的为：{file}')
            get_file(i)
        else:
            file_list.append(file)
            with open(i, 'r', encoding='utf-8')as readfile:
                read = readfile.read()
            with open('write0724', 'a', encoding='utf-8') as writefile:
                writefile.write(read)

            # return file


# def readwrite(list):
#     for file in list:
#         with open(file, 'r', encoding='utf-8') as readfile:
#             read_text = readfile.read()
#         with open('pythonstudy/26_文件操作/write0723', 'a', encoding='utf-8') as writefile:
#             writefile.write(read_text)


if __name__ == '__main__':
    path = '/Users/sunwenxiao/PycharmProjects/study_python/pythonstudy/25_模块'
    file_list = []
    get_file(path)
    print(file_list)




